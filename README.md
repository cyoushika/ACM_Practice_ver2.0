
《算法竞赛入门经典》（小白书）与《算法竞赛入门经典训练指南》（大白书）的习题笔记

# 小白书

## 第六章--数据结构：

- ### 线性表：
- #### UVAOJ 127 "Accordian" Patience （模拟，结构体+链表）
	- 题目大意：给你五十二张牌, 重复下列操作，直至无法操作：从左到右遍历，当扑克牌与其左一或左三的扑克牌堆顶部牌拥有过相同的花色或者相同数字时，即为匹配成功，将该扑克牌移到匹配的左一或左三的牌堆顶部。如果同时可以移到左一和左三，则优先移到左三顶部。移动之后，观察能否再次移动，直至不能移动，继续遍历下一张牌。当一个牌堆的所有牌都被移走时，删除这个牌堆，右边的牌堆补上空缺。现在求有多少牌堆会剩下，以及各牌堆有多少张牌。
	- 思路：建立卡牌的结构体保存花色和卡牌，建立牌堆的结构体保存卡牌，左右牌堆的指针，当前牌数。然后根据输入顺序建立牌堆的链表，每个牌堆的初始卡牌即为输入的相应卡牌。先看左三牌堆（需确认左三存在），再看左一牌堆，匹配的时候移动卡牌
	----
- #### UVAOJ 101 The Blocks Problem （模拟，结构体+链表）
	- 题目大意：给N个小方块，从左到右编号（0~N-1），形成N个块堆，可进行4种操作：
		- （1）move A onto B：将A方块和B方块上的所有方块回归原位，然后将A放在B上
		- （2）move A over B：将A方块上的所有方块回归原位，然后将A放在B所在的块堆顶部
		- （3）pile A onto B：将B方块上的所有方块回归原位，然后将A及其以上的方块整体移到B上（移动过程中A及其以上的方块保持原来的上下顺序不变）
		- （4）pile A over B：将A及其以上的方块整体移动到B所在的快堆顶部上（移动过程中A及其以上的方块保持原来的上下顺序不变）
		- 现在给出一系列命令，输出所有操作结束以后，各块堆的拥有的方块
	- 思路：模拟，创建方块的结构体保存方块编号和上下信息，创建方块结构体的数组，根据命令进行操作。最后遍历结构体数组，如果该方块下方存在别的方块，则意味着它不在自己的块堆，不输出信息；如果下方不存在别的方块，则从下向上输出自己以及以上的方块的信息。因为所有操作都是将方块放在另一个方块的上方，而不是下方，所以不存在“自己在别的块堆，而自己的块堆存在别的方块”的情况
	----
- #### UVAOJ 133 The Dole Queue （链表）
	- 题目大意：有N个候选人和2个领导。候选人面朝内手拉手围成一个圈，每个人都有自己的编号，从1到N，1号候选人的左手边为N号候选人。1个领导从1号开始逆时针点人（包括1号），最终被点到的人会离开队伍，而离开队伍的人的左右两边的候选人会重新拉手；2号领导从N号开始顺时针点人（包含N号）。在点完人后，领导会按自己点人方向选择下一个候选人，并从该候选人开始继续点人，直到所有人都离开。求离开队伍的人的顺序
	- 限制条件：
		1. 被两个领导点到的候选人会同时离开队伍
		2. 被两个领导同时点到的候选人也会离开队伍，但输出只会输出一次
	- 思路：题目不难，创建链表，将所有节点按顺序相连，每次有人离开时，相邻节点重新相连。需要注意的是离队后领导指向的下一个候选人的选择。虽然题目说是同时离开，但代码执行的时候是有先后的，如果一个领导的下一个候选人正好是另一个领导这次点名的人，那么应该顺延到再下一个（当剩下的候选人总是小于等于2时，可认定不存在下一个合格的候选人，不应该继续遍历）
	---
- #### UVAOJ 10152 ShellSort （结构体+数组）
	- 题目大意：给两套字符串，一套为现在的顺序（从上到下），一套为目标的顺序（从上到下），现在可以对现有字符串组进行操作：将任意字符串抽出，放在整组字符串的最顶部。求，从现有顺序到目标顺序的操作顺序（要求操作次数最少）
	- 思路：目标组中越底部的字符串越需要尽早操作，所以从现有组和目标组底部开始对比，如果匹配，则意味着不需要对该字符串进行操作，对目标组该字符串进行标记；如果不匹配，则不标记。在对现有组进行操作时，上面的字符串会下落，如果弥补空缺的那个字符串正好是它的目标位置，则可以不需要对它操作又能达到目标位置，减少了字符串的操作次数。最后，从底部遍历目标组，按序输出没有被标记的字符串。
	---
- #### UVAOJ 673 Parentheses Balance （栈）
	- 题目大意：输入一串括号的字符串，判断是否合规
	- 思路：遇到左括号就压入栈，遇到右括号就弹出栈顶元素，看是否匹配；当然也可以用数组模拟栈
	---
- #### UVAOJ 442 Matrix Chain Multiplication （结构体+栈+矩阵乘法）
	- 题目大意：矩阵乘法的先后计算顺序会影响计算的速度，当A（50,10），B（10，20），C（20,10）三个矩阵相乘时，先计算AB再计算AB和C时，需要进行15000次元素间的乘法计算；而先计算BC再计算A和BC时，只需要进行3500次乘法计算。现在给出一些算式，其中会包含矩阵和一些括号，求各算式的乘法计算的次数。
	- 思路：用结构体保存矩阵的行数和列数，用数组（矩阵名-'A'）或者Map（map<char, 矩阵结构体>）保存矩阵名与矩阵结构体的映射。设一个结构体类型的栈，忽略'('，遇到矩阵就压入栈，遇到')'就弹出顶部的两个矩阵相乘，将结果压入栈。
	- 矩阵乘法次数的计算：MxN的矩阵\*NxP的矩阵 = MxNxP
	- 矩阵乘法：MxN的矩阵\*NxP的矩阵 = MxP的矩阵
---
- #### UVAOJ 11111 Generalized Matrioshkas（结构体+栈）
	- 题目大意：俄罗斯套娃，用一个正数和一个负数表示拆开的套娃的两半部分，正数表示套娃内的容积。与只能套一个套娃的传统套娃不同，新版套娃可以包含多个套娃，套娃中又可以包含多个套娃。给一串数字，判断是否能组成一个合规的套娃。（题目不难，但是有些关键信息没给，做的很痛苦）
	- 限制条件：
		1. 大套娃内部包含的小套娃总体积必须小于大套娃的容积
		2. 套娃内部的小套娃必须是完整的（即必须负数与正数成对）
		3. 虽然题目没讲，但是Debug数据中表示，空字符串也是合规的
		4. 虽然题目没讲，但是本题的数组最少需要开30000以上的空间
	- 思路：结构体保存套娃的容积以及小套娃的总体积，开一个结构体Stack，当遇到负数时，压入栈；当遇到正数时，弹出栈顶的结构体，判断是否配套。配套时，看自己的小套娃总体积是否超过自己的容积。不超过容积时，将自己的体积添加到上一层套娃的小套娃总体积中。继续遍历...
	- 后记：重新学习了sscanf的用法，避免了繁琐的getchar+ctype判断的流程...代码中使用了sscanf(p, "%d%n",&value,&n), p是指向字符串的指针，value是输入的数字，n表示位移的位置，p+=n就可以从下一个数据开头开始继续遍历输入。
---
- #### UVAOJ 11234 Expressions（二叉树与层遍历BFS模拟）
	- 题目大意：后序计算是栈计算，每次遇到算术符号时，弹出栈顶部的两个元素，运算，再将结果压入栈内。现在希望通过用队列实现栈计算一样的结果。即，输入栈计算的字符串，输出队列计算的字符串
	- 思路1：建立二叉树，逐层遍历
	- 思路2：模拟遍历过程
		- 通过观察发现，字符串的最后一个元素一定是树的根节点。同时，字符串从右至左的节点顺序，是基于根节点的广度优先遍历（BFS）结果，即：
			- 根节点->左子树节点->右子树节点
			- （左子树节点）->（左）左节点->（左）右节点
			- （右子树节点）->（右）左节点->（右）右节点
			- （（左）左节点）-> 左节点 -> 右节点
			-  ...
		- 如何寻找左右树根节点：通过观察，大写字母的数量+1 = 小写字母的数量，即算子的数量总是运算符+1。
		- 从右向左，自根节点的下一个字母开始计算大写字母数量和小写字母数量，当检查到第i个字母 && 小写字母数量=大写字母+1时，即找到了一棵子树的根节点的位置（i+小写字母-1+大写字母），保存根节点的字母并标记位置，从位置i开始遍历寻找另一个子树的根节点位置...
		- 从左子树根节点位置开始遍历，寻找左子树的两个子树根节点，添加；再从右子树根节点位置开始遍历，寻找右子树的两个子树根节点，添加；左子树的左子树...左子树的右子树...右子树的左子树...右子树的右子树...直到所有节点都遍历完毕。即为队列计算

	---
- #### UVAOJ 540 Team Queue（Map+双队列）
	- 题目大意：模拟队伍队列的进出过程
	- 限制条件：
		1.	从队列前头遍历，如果队列中有同一个队伍的成员，则插入同队伍成员的最后；如果没有同队伍成员，则插入整个队列的最后
		2.	出队列时，整个队列最前头的成员离开
		3.	可能有超过20万条命令，故插入和出队列的耗时必须短
	- 思路：双队列保存队伍状态和各队伍成员状态
		- queue< int > qteam, qmember[MAXN] : qteam 保存的是整个队列中存在的队列ID，
		   i = qteam.front()返回最前端队列，qmember[i]表示队伍i的队伍
		（还是写的少了...queue居然还可以做成数组...）
		- map<int, int> team：字典，建立成员与队伍id的映射，team[value]返回的是成员value的队伍
	---
- #### UVAOJ 10050 Hartals (数组记录过程)
	- 题目大意：给p个数表示各组织活动的周期，求在D天内发生的活动总和
	- 限制条件：
		1. p不会是7的倍数
		2. 第一天必定是星期天
		3. 周五和周六是假期，不会发生活动
		4. 同一天发生多次活动的时候，仅计算一次
	- 思路：
		-	设定一个数组记录D天的每一天是否发生过活动，D[i]=0表示第i天还没有发生过活动，D[i]=1表示第i天已经发生过活动。
		-	设day=p[i]，循环day+=p[i]（day<D），判断那天是否发生过活动以及那天是否为周五或周六
		-	判断周五/周六的办法，day **mod** 7 = 5时为星期五，= 6时为星期六
---
- ### 二叉树：
- #### UVAOJ112 Tree Summing（树+DFS）
	- 题目大意：给一个整数+若干字符串，表示目标和二叉树的构成。从根到每个叶子节点的路径为一条合格路径，路径上所有节点的总和为这条路径的结果。求是否存在一条路径的结果与目标整数相等
	- 限制条件：一个二叉树的输入可能会包含空格，或者好几行
	- 思路：没什么好讲的，首先整理输入，去掉所有的空格和回车，获得二叉树的完整输入。再遍历输入，构筑二叉树：读到“(”，就是子节点，读到“)”就是子节点输入完成，读到“()”意味着子节点为空。之后用DFS遍历二叉树，对比路径的总和与目标数字，最后输出结果。
	---
- #### UVAOJ548 Tree（模拟树+结构体）
	- 题目大意：给一个二叉树的中序队列的后序队列，求树中路径值最小的路径
	- 限制条件：当存在相同路径值的路径时，应该选叶子节点值最小的路径
	- 思路：因为已经知道中序和后序，可以完全模拟树的构建和访问过程。构建结构体保存路径的值和叶。
	- 后序倒数第一个元素必定为树的根节点
	- 到中序数列中找到根节点位置，标记，然后查看左右两边的节点是否访问过（最左节点的左边和最右节点的右边都视为已访问），如果两边都已访问，则该节点为叶节点，记录路径值以及路径叶节点，递归结束。
	- 如果只有左边已访问，则该节点只有右子树，继续递归右子树；如果只有右边已访问，则该节点只有左子树，继续递归左子树。
	- 当树完全遍历之后，对路径结构体数组进行排序（本人使用了结构体内的小于号重构，方便使用Algorithm的sort函数，当然也可以使用Stalib的qsort，cmp函数写法不再赘述）
	---
- #### UVAOJ297 Quadtrees（树+DFS）
- 题目大意：有一个32x32的图片，可以用四分树来表示，f表示该区域全为黑色，e表示该区域全为白色，p表示该区域有更细致的划分（即将当前区域分成4份，分别用一个节点表示其颜色，如果其中有p节点，那就意味着那个节点的区域又被分为4分，又其四个子节点进行涂色）。现在想将两个图片重叠在一起，只要两个图片中有一个该区域为黑色，则重叠后该区域就为黑色，现在求重叠后黑色像素的总数。
- 思路：
	- 最开始构建了两棵树，然后同步DFS遍历，但RuntimeError了，也不知道是因为递归太多内存不够还是代码写的有缺陷...Debug案例都过了...无奈优化思路。因为两棵树最终要重叠到一起，那么在第一棵树的基础上构建第二棵树就能省去1倍的递归数量和一棵树的内存空间...构建树，每个节点保存自己的颜色和深度，如果节点=p，则递归构建子树；如果节点=f，则节点颜色为1，如果节点=e，则不操作。第二棵树直接从第一棵树的根节点开始构建，如果第二棵树的节点为f，则改变节点颜色为1（无论原先是什么颜色，重叠以后都为黑色）；如果第二棵树的节点为p，则继续构建子树（不改变颜色，如果原来为e，那DFS时会忽略，只要有子节点就视为p节点，相当于用p覆盖了e；如果原来为f，那么DFS时会直接计算整个区域的像素数，不会继续访问下面的子节点，相当于p被f覆盖；如果原来为p节点，则两个p的子节点会互相覆盖）。
	- DFS：遇到黑色节点，sum+=1024/(4,深度)，根节点深度为0，每次遇到p，其子节点就加一层深度，用来模拟四分区域；遇到非黑色节点，若存在子节点，则继续遍历子树。
	---
- #### UVAOJ712 S-Trees（二叉树）
	- 题目大意：有一棵S树，每一层节点（除叶节点）的数值相同，而各层的数值不同，各层数值由题目给定的x1,x2,x3,···xn顺序以及信号输入VVA确定。此外，叶节点的数值为0或者1，也由题目给定。现在给出x1, x2, x3...的顺序，以及信号输入VVA，当该节点的值为0时，向左子树递归，而值为1时，向右子树递归，求最终输出的结果。
	- 思路：根据题目要求建立二叉树，然后根据VVA和编码顺序遍历树，输出结果...
	---
- #### UVAOJ699 The Falling Leaves（模拟二叉树）
	- 题目大意：有一棵二叉树，现在将所有节点垂直落到同一个水平线上，相同水平位置的节点的数字相加，求最终有多少堆节点，各堆的值为多少
	- 思路：老老实实地建了树，然后计算最左和最右的偏移量，遍历整个树，将同一水平位置的节点加到数组中，最后输出数组各元素的值...但是RuntimeError了，应该是有bug，但Debug案例都过了，找不出哪儿有问题...遂换思路，其实可以模拟树：建一个足够大的数组，取中间位置为水平原点，保存根节点数值，然后向左右子树遍历，每往左1次，水平位置就-1，每往右1次，水平位置就+1；就这样，找到数组第一个非零元素，开始输出，直至遇到0
	---
- #### UVAOJ327 Evaluating Simple C Expressions（没看懂为什么刘神说这个题是树的题...应该是字符串处理...）
	- 题目大意：给一串计算式，其中变量为a~z，分别代表1 ~ 26，求计算式结果，以及各变量的最终数值。
	- 思路：先处理输入的字符串，去掉所有的空格。因为题目说不会出现++a++，--a--，a+++b这样的迷惑输入，所以可以不用担心。设置两个数组（也可以用map），一个用来保存各变量的当前数值，一个用来保存各变量的最终数值，去掉空格的字符串后，先处理前置++和前置--，每次找到变量，就开始看其前两个字节，如果均为+或者均为-，则为前置++/--，计算当前数值数组和最终数值数组；然后看其后两个字节，如果均为+或者均为-，则为后置++/--，计算最终数值数组；继续遍历，如果前面无别的符号，则该变量为第一个变量，直接加，如果前面为-，则减；为+，则加；最终输出结果
	---
- #### UVAOJ893 No so Mobile (树+DFS)
	- 题目大意：给出一系列数字，每一行有4个数字，分别代表左节点配重wl，左节点力矩dl，右节点配重wr，右节点力矩dr，如果wl\*dl！=wr\*dr，则不平衡；反之，则保持了平衡。如果wl或wr为0，则意味着它下面还有子节点，所有子节点的重量即为该节点的配重。求给出的一系列数字构建出的树是否平衡（即所有节点都平衡）。
	- 思路：建树，wl要么为输入的wl，要么为子树的配重总和，递归构建子树，wr也如此递归构建，之后判断是否平衡，并更新自己的配重 wl+wr。
	----
- #### UVAOJ10562 Undraw the Trees (字符串处理+DFS)
	- 题目大意：给出一系列字符串，将其转化为节点与括号的形式
	- 思路：又是一个名字上跟树有关，但实际上是字符串处理，然而又和树的遍历的模拟有关的题...hummm...不需要建立树，首先排除几个特殊情况，比如只有一个#（意味着空树）时，应该只输出“（）”；在树的第一个节点出现前，可能会有大量的空白行，应该予以跳过，从有子节点的那行开始遍历；只有一个节点时，应输出“（节点（））”...另外，**在混合使用scanf和fgets/gets时，务必注意回车字符的处理！记得在scanf后用getchar把回车吃掉**...读入一行字符串，当遇到节点（非“ ”，“|”，“#”，“-”）时，输出该字符，向下看一行，看看是否有“|”，如果有，则向再下一行进行DFS递归，判断“----”的范围后，再向下读一行根据范围处理节点；如果没有“|”，则直接输出“（）”
	---
- ### 图与图遍历：
- #### UVAOJ572 （DFS遍历）
	- 题目大意：有一块地，分成好多个格子，每个格子可能有石油，也可能没有，相邻（包括斜方向）有石油的格子视作一片石油。现在问，这块地有多少片石油？
	- 思路：经典的DFS遍历问题。从头开始检查，遇到有石油的格子时标记本格子，然后开始遍历其八个方向，如果遇到有石油的格子就继续以那个格子为中心遍历其八个方向；如果遇到空格子或者边界时就停止遍历。
	----
- #### UVAOJ657 （双层DFS遍历）
	- 题目大意：给一个图片，由“.”（背景）、“*”（骰子）、“X”（骰子纹）构成，现在求里面每个骰子的数字
	- 限制条件：每个骰子的数字=X的数量，上下左右相邻的X视作同一个X
	- 思路：当遇到“*”时，开始遍历上下左右四个方向的格子：遇到“\*”时继续遍历和标记，遇到“X”时，换到遍历X的DFS，将所有相连的X标记，骰子点数+1。
	- +α：只实现上面的功能就可以AC了，所以题目数据应该是没有不含“*”只有“X”的骰子。但是Debug里是有的，所以AC的代码测试Debug数据是会WA的...解决办法是，先遍历所有带\*的骰子，再遍历所有只有X的骰子。
	----
- #### UVAOJ784（DFS遍历）
	- 题目大意：给一个迷宫，从“\*”开始遍历，将所有走过的地方涂色，直至没有可以走的地方，最终输出涂完色的迷宫
	- 思路：先寻找\*，然后开始DFS上下左右四个方向，遇到非空格子就停下，遇到空格子时涂色，迭代遍历。
	----
- #### UVAOJ705（FloodFill）
	- 题目大意：一个迷宫，由“/”和“\”构成。现在，求迷宫中所有形成环的通路数量，以及最长通路的长度。
	- 思路：经典的斜线迷宫问题，使用FloodFill算法解决。FloodFill的意思是，以某一点为中心，向周围所有可以到达的点蔓延，所有到达的点均标记/标色，直至没有可以蔓延的点。本问题中，所有没有办法形成环的区域，最终都会蔓延到边界以外，所以先从边界FloodFill把所有非环区域标记出去。为了将迷宫转化成可遍历计算的迷宫，有三种操作方法：九分法，四分法，光束反射法
	- **九分法**：将“/”和“\”转化成3x3的格子，标记有线的格子（比如“#”），其余格子为为空（比如空格）。将迷宫重构之后开始从边界FloodFill上下左右四个方向，将所有的非环区域都标记。之后开始从头遍历，当遇到合规格子时，开始遍历，统计格子数，结束后格子数÷3，即为路径长度，与最长的路径记录对比，更新。
	- **四分法**：将“/”和“\”转化成2x2的格子，标记有线的格子（比如“#”），其余格子为为空（比如空格）。将迷宫重构之后开始从边界FloodFill上下左右四个方向后，再FloodFill斜方向的上下左右，将所有的非环区域都标记。**需要注意的是，四分法由于构造问题，需要判断是否跨线（/或\的中间，或者\和\\, /和/, \和/的交点处）**，之后开始从头遍历，当遇到合规格子时，开始遍历，统计格子数，结束后格子数即为路径长度，与最长的路径记录对比，更新。
	- **光束反射法**：不是很懂...可以参考[CSDN里的FloodFill代码示例](https://blog.csdn.net/ra_winding/article/details/7724290)...
	----
- #### UVAOJ439 (BFS)
	- 题目大意：给一个国际象棋盘，给两个坐标，一个是起点，一个是终点，现在求一个骑士最少需要多少步才能到达终点的坐标
	- 限制条件：
		- 国际象棋盘的行标是数字，列标为字母，所以题目输入其实是先给列标再给行标
		- 骑士和中国象棋里的马的规则相同，走日字
	- 思路：经典BFS题目，创建一个队列用来保存接下来需要遍历的点和步数，队列的初元素为起点的坐标以及步数（Step=0）。初始化后从起点开始遍历，所有能到达的点都加入队列的末端，然后从队列的首端取一个点，标记访问的点，更新Step，继续遍历。
	- **DFS和BFS：DFS是栈，遇到合法的点就压入栈，走不下去的时候就退一步，换一个方向，这样“一条路走到黑，不到南墙不回头”，所以DFS适合处理存在问题（是否存在XXX满足YYY）；BFS是队列，遇到合法的点就压入队列末端，每次遍历结束就从队列首部取下一个遍历点，总是一层一层更新路径长度，所以到达目标的时候一定是最优解，适合处理最优问题（最少XXX，最短XXX）。虽然二者都能实现全图遍历的功能，但是个人感觉上，像涂色的全遍历问题，DFS更方便，写起来更简单一些..**
	----
- #### UVAOJ532 （BFS）
	- 题目大意：给一个三维迷宫，S表示起点，E表示终点，#表示墙壁，.表示通路，可以向上下左右前后移动，每次移动都要消耗1分钟时间，求到达终点最少需要多长时间。
	- 思路：最优问题，BFS，比一般的BFS多了两个探索方向，其他的没有区别
	----
- #### UVAOJ10557 （双DFS, 或者单BFS）
	- 题目大意：模拟Adventure（游戏），给出一系列房间和信息（能量值，门的数量，各个门可到达的房间），现在求能否从初始房间到达目标房间
	- 限制条件：
		- 初始房间为第一个房间，初始能量为100
		- 每个房间的门都是单向门，从1到2的门不可以再从同一个门回到1
		- 可能存在环，即有房间的单向门通向之前访问过的房间
		- 当能量为0时，判负
		- 当无法到达最后一个房间时，判负
	- 思路（双DFS）：首先需要用结构体来保存各个房间的信息（消耗/补充的能量，门的数量，可通往的房间的数组，以及上次访问这个房间的时候剩余的能量），然后从第一个房间开始遍历：先判定能量值，如果小于等于0则直接判负；然后判定是否为目标房间，如果是则判胜；判定是否曾经来过这个房间，即history energy！=-1，比较当前能量和历史记录，如果当前能量高，则为正环，能量不再是问题，以这个点为起点进行第二层DFS，只考虑是否访问过那个房间，以及是否到达了目标房间，如果到达就判胜，否则判负；如果历史记录高，则为负环，循环没有意义，直接判负；
	- 思路（单BFS）：依然是用结构体保存各个房间的信息，然后从第一个房间开始遍历：先判定能量值，如果小于等于0则直接判负；然后判定是否为目标房间，如果是则判胜；因为BFS的特性（添加非环内的房间到队列），如果能够到达终点，是不会一直卡在循环里的，如果是正环，当能量值达到非常高的值时，就可以认为是卡在正环里了，退出判负；如果是负环，自然会有能量值小于等于0的时候，自然就退出判负了。
	----
- #### UVAOJ10047（最优队列BFS）
	- 题目大意：有一个骑着独轮车的人，这个独轮车被分成5份，每份都被涂上了不同的颜色。每次移动，车轮都会完美旋转72度，所以会完美转移到下一个颜色；每次调整朝向以及移动都消耗1秒。现在这个人从迷宫的起始点（面朝北，绿色部分接触地面），到达终点时，朝向无所谓，但是车轮必须是绿色部分接触地面，求能否到达终点，以及到达终点时的时间。
	- 思路：一般BFS是不对候选队列进行维护的，每次都取最先头的元素进行遍历和判断，visit数组也仅用于记录是否访问过该点。而本题中，不仅需要对BFS进行维护，visit数组也需要保存该点的最优信息。从起始位置开始遍历，起始朝向为北，可移动方向为北南西东，当朝向一致时，仅消耗1s移动时间；当朝向相反时，需要3s时间（1s移动+2s转向）；其余消耗2s时间（1s移动+1秒转向）。每次到达一个点，判断是否超出边界->是否为目标地点->**之前是否以底部颜色为C，朝向为D的状态到过该点 AND 到达该点时的消耗总时间是否比上次到达的时间短（维护visit数组）**->**将当前状态以消耗时间短为序插入到队列中（维护候选Queue）**->继续遍历。
	----
# 大白书
## 第一章--算法基础设计
- ### UVAOJ11292 The Fragon of Loowater （排序）
	- 题目大意：有一条n个头的龙，需要雇佣勇者去屠龙，已知可雇佣的勇者的能力X，可以砍下直径不超过X的龙头，佣金为X，求能否用最少的金钱屠龙，如果可以，输出金钱；否则，输出对应文本。
	- 限制条件：每个勇者只能雇用一次，且一次只能砍一个头
	- 思路：对龙头和勇者的能力分别进行排序，从小开始遍历勇者和龙头，当勇者不能砍下当前龙头时，寻找下一个勇者；当龙头被砍下时，佣金+=X，寻找下一个勇者和下一个龙头。
	---
-	### UVAOJ11729 Commando War （贪心，结构体）
	-	题目大意：有一系列任务需要布置给下属完成，每个任务消耗X分钟交待，需要下属消耗Y分钟完成。一旦交待完成，就可以继续交待下一个任务给另一个下属，而下属们可以同时处理他们自己的任务，求完成所有任务所消耗的最少的时间。
	-	思路：需要考虑几种情况，
		1. 假设，任务A的总耗时比任务B的执行时间短。则，先执行A再执行B，耗时为（Xa+Xb+Yb）；先执行B再执行A，耗时为（Xb+Yb）< （Xa+Xb+Yb）
		2. 假设，任务A的总耗时比任务B的执行时间长，但比任务B的总耗时短。则，先执行A再执行B的耗时为（Xa+Xb+Yb）；先执行B再执行A，耗时为（Xb+Xa+Ya）。由此可见，若任务A的执行时间大于任务B的执行时间，那么应该先执行A；若任务B的执行时间大于任务A的执行时间时，应该先执行B；且这个安排于A，B的交待时间无关
		3. 如果出现一个任务A总耗时比任务B的总耗时长，那么就是假设2的倒置情况，依然需要满足“执行时间长的应该先执行”的原则。
	- 基于上面的假设，建立任务的结构体，依照执行时间对所有任务进行排序。然后统计执行时间：Xs+=X（累计交待时间），time = max（time，Xs+Y）
---
- ### UVAOJ11300 Spreading The Wealth （数论）
	- 题目大意：圆桌旁坐着n个人，每个人都有一定数量的金币，金币总数能被n整除。每个人可以给左右相邻的人一些金币，最终使得每个人的金币数目相等。求被转手的金币数量的最小值。
	- 思路：
		- 最终金币数M=（所有金币数）/人数
		- 对于第一个人，初始金币A1，他给左边的人x1个金币，又收到右边的人x2个金币，现在第一个人的总金币数=A1-x1+x2=M，通过调整可得：x2=M-A1+x1=x1-C1，C1=A1-M+C0, C0=0
		- 对于第二个人，初始金币A2，他给左边的人x2个金币，又收到右边的人x3个金币，现在第一个人的总金币数=A2-x2+x3=M，通过调整可得：x3=M-A2+x2=x1-C2，C2=A2-M+C1
		- ...
		- 对于第N-1个人，初始金币An-1，他给左边的人xn-1个金币，又收到右边的人xn个金币，现在第N-1个人的总金币数=An-1-xn-1+xn=M，调整可得：xn=M-An-1+xn-1 = x1-Cn-1, Cn-1 = An-1-M+Cn-2
		- 对于第N个人，初始金币An，他给左边的人xn个金币，有收到右手边（第一个人）给的x1个金币，那么第N个人的总金币数=An-xn+x1=M，然而我们从中并不能推导出有用的信息。因为当所有人（除第N个人）给出和收到的金币确定时，第N个人需要给的和收到的金币也随之确定
		- 由上述所有的算式可得，需要转手的硬币总数为|x1-C0|+|x1-C1|+|x1-C2|+...+|xn-Cn-1|，而题目需要这个总数最小（C0=0）。几何角度来讲，|x1-Ci|表示的是数轴上x1到点Ci的距离，那么问题就转化成，找到一个点，使得这个点到所有其他点的距离最小。**这里需要用到一个数论理论：有序数列中，中位数到各点的距离一定是最短的。如果数列内元素数量为奇数，那么中位数就是中间的那个元素；如果为偶数，那么中位数就是中间两个元素之间的任意位置（因为这个点位于中间时，不论向左还是向右移动，与一边各点增加的距离永远等于与另一边各点减少的距离）**。
		- 根据上面的推导，计算各个Ci，进行排序，然后选出中位数，最后累加起来
		---
- ### LA3708 Graveyard （缩放+数论）
- 题目大意：在一个周长为10000的圆上等距分布着n个雕像，现在要加入m个雕像（位置随意摆放），希望所有n+m个雕像在圆周上均匀分布，就必须移动一部分已有的雕像，求最小的移动距离总和。
- 思路：n个雕像中，要达到最小移动距离，必有1个雕像不需要移动，原理类似于: 因为一个有序数列中，中位数到所有点的距离之和最小
	- 将圆缩放10000倍，并以一个雕像为原点，计算其余n-1个雕像的距离，并以此作为数轴坐标，比如n=3，那么三个点的坐标为，0, 1/3, 2/3
	- 将单位圆放大n+m倍，得到三个点新的坐标0, 4/3, 8/3。这么做的理由是：通过放大n+m倍，可使所有雕像的坐标都是整数，且彼此之间的距离为1。也正因为所有雕像的坐标在添加m个新雕像后必然为整数，所以可以通过新坐标计算到最近整数点的距离R
	- 会不会有两个雕像的最近整数点相同，而撞到一起呢？答案是不会。因为如果他们整数点坐标相同，那么他们的现有坐标之间的距离应该不超过1，然而在添加m个雕像后，彼此之间的距离才会到1，没添加之前应该比1大才对。故，不会出现撞车的情况
	- 计算出R之后，再缩放n+m倍，得到单位圆下的移动距离，累加起来，再放大10000倍，即是移动距离的最小值。
	----

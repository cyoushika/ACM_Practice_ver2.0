《算法竞赛入门经典》（小白书）与《算法竞赛入门经典训练指南》（大白书）的习题笔记

# 小白书

## 第六章--数据结构：

- ### 线性表：
- #### UVAOJ 127 "Accordian" Patience （模拟，结构体+链表）
	- 题目大意：给你五十二张牌, 重复下列操作，直至无法操作：从左到右遍历，当扑克牌与其左一或左三的扑克牌堆顶部牌拥有过相同的花色或者相同数字时，即为匹配成功，将该扑克牌移到匹配的左一或左三的牌堆顶部。如果同时可以移到左一和左三，则优先移到左三顶部。移动之后，观察能否再次移动，直至不能移动，继续遍历下一张牌。当一个牌堆的所有牌都被移走时，删除这个牌堆，右边的牌堆补上空缺。现在求有多少牌堆会剩下，以及各牌堆有多少张牌。
	- 思路：建立卡牌的结构体保存花色和卡牌，建立牌堆的结构体保存卡牌，左右牌堆的指针，当前牌数。然后根据输入顺序建立牌堆的链表，每个牌堆的初始卡牌即为输入的相应卡牌。先看左三牌堆（需确认左三存在），再看左一牌堆，匹配的时候移动卡牌
	----
- #### UVAOJ 101 The Blocks Problem （模拟，结构体+链表）
	- 题目大意：给N个小方块，从左到右编号（0~N-1），形成N个块堆，可进行4种操作：
		- （1）move A onto B：将A方块和B方块上的所有方块回归原位，然后将A放在B上
		- （2）move A over B：将A方块上的所有方块回归原位，然后将A放在B所在的块堆顶部
		- （3）pile A onto B：将B方块上的所有方块回归原位，然后将A及其以上的方块整体移到B上（移动过程中A及其以上的方块保持原来的上下顺序不变）
		- （4）pile A over B：将A及其以上的方块整体移动到B所在的快堆顶部上（移动过程中A及其以上的方块保持原来的上下顺序不变）
		- 现在给出一系列命令，输出所有操作结束以后，各块堆的拥有的方块
	- 思路：模拟，创建方块的结构体保存方块编号和上下信息，创建方块结构体的数组，根据命令进行操作。最后遍历结构体数组，如果该方块下方存在别的方块，则意味着它不在自己的块堆，不输出信息；如果下方不存在别的方块，则从下向上输出自己以及以上的方块的信息。因为所有操作都是将方块放在另一个方块的上方，而不是下方，所以不存在“自己在别的块堆，而自己的块堆存在别的方块”的情况
	----
- #### UVAOJ 133 The Dole Queue （链表）
	- 题目大意：有N个候选人和2个领导。候选人面朝内手拉手围成一个圈，每个人都有自己的编号，从1到N，1号候选人的左手边为N号候选人。1个领导从1号开始逆时针点人（包括1号），最终被点到的人会离开队伍，而离开队伍的人的左右两边的候选人会重新拉手；2号领导从N号开始顺时针点人（包含N号）。在点完人后，领导会按自己点人方向选择下一个候选人，并从该候选人开始继续点人，直到所有人都离开。求离开队伍的人的顺序
	- 限制条件：
		1. 被两个领导点到的候选人会同时离开队伍
		2. 被两个领导同时点到的候选人也会离开队伍，但输出只会输出一次
	- 思路：题目不难，创建链表，将所有节点按顺序相连，每次有人离开时，相邻节点重新相连。需要注意的是离队后领导指向的下一个候选人的选择。虽然题目说是同时离开，但代码执行的时候是有先后的，如果一个领导的下一个候选人正好是另一个领导这次点名的人，那么应该顺延到再下一个（当剩下的候选人总是小于等于2时，可认定不存在下一个合格的候选人，不应该继续遍历）
	---
- #### UVAOJ 10152 ShellSort （结构体+数组）
	- 题目大意：给两套字符串，一套为现在的顺序（从上到下），一套为目标的顺序（从上到下），现在可以对现有字符串组进行操作：将任意字符串抽出，放在整组字符串的最顶部。求，从现有顺序到目标顺序的操作顺序（要求操作次数最少）
	- 思路：目标组中越底部的字符串越需要尽早操作，所以从现有组和目标组底部开始对比，如果匹配，则意味着不需要对该字符串进行操作，对目标组该字符串进行标记；如果不匹配，则不标记。在对现有组进行操作时，上面的字符串会下落，如果弥补空缺的那个字符串正好是它的目标位置，则可以不需要对它操作又能达到目标位置，减少了字符串的操作次数。最后，从底部遍历目标组，按序输出没有被标记的字符串。
	---
- #### UVAOJ 673 Parentheses Balance （栈）
	- 题目大意：输入一串括号的字符串，判断是否合规
	- 思路：遇到左括号就压入栈，遇到右括号就弹出栈顶元素，看是否匹配；当然也可以用数组模拟栈
	---
- #### UVAOJ 442 Matrix Chain Multiplication （结构体+栈+矩阵乘法）
	- 题目大意：矩阵乘法的先后计算顺序会影响计算的速度，当A（50,10），B（10，20），C（20,10）三个矩阵相乘时，先计算AB再计算AB和C时，需要进行15000次元素间的乘法计算；而先计算BC再计算A和BC时，只需要进行3500次乘法计算。现在给出一些算式，其中会包含矩阵和一些括号，求各算式的乘法计算的次数。
	- 思路：用结构体保存矩阵的行数和列数，用数组（矩阵名-'A'）或者Map（map<char, 矩阵结构体>）保存矩阵名与矩阵结构体的映射。设一个结构体类型的栈，忽略'('，遇到矩阵就压入栈，遇到')'就弹出顶部的两个矩阵相乘，将结果压入栈。
	- 矩阵乘法次数的计算：MxN的矩阵*NxP的矩阵 = MxNxP
	- 矩阵乘法：MxN的矩阵*NxP的矩阵 = MxP的矩阵
---
- #### UVAOJ 11111 Generalized Matrioshkas（结构体+栈）
	- 题目大意：俄罗斯套娃，用一个正数和一个负数表示拆开的套娃的两半部分，正数表示套娃内的容积。与只能套一个套娃的传统套娃不同，新版套娃可以包含多个套娃，套娃中又可以包含多个套娃。给一串数字，判断是否能组成一个合规的套娃。（题目不难，但是有些关键信息没给，做的很痛苦）
	- 限制条件：
		1. 大套娃内部包含的小套娃总体积必须小于大套娃的容积
		2. 套娃内部的小套娃必须是完整的（即必须负数与正数成对）
		3. 虽然题目没讲，但是Debug数据中表示，空字符串也是合规的
		4. 虽然题目没讲，但是本题的数组最少需要开30000以上的空间
	- 思路：结构体保存套娃的容积以及小套娃的总体积，开一个结构体Stack，当遇到负数时，压入栈；当遇到正数时，弹出栈顶的结构体，判断是否配套。配套时，看自己的小套娃总体积是否超过自己的容积。不超过容积时，将自己的体积添加到上一层套娃的小套娃总体积中。继续遍历...
---
- #### UVAOJ 11234 Expressions（二叉树与层遍历BFS模拟）
	- 题目大意：后序计算是栈计算，每次遇到算术符号时，弹出栈顶部的两个元素，运算，再将结果压入栈内。现在希望通过用队列实现栈计算一样的结果。即，输入栈计算的字符串，输出队列计算的字符串
	- 思路1：建立二叉树，逐层遍历
	- 思路2：模拟遍历过程
		- 通过观察发现，字符串的最后一个元素一定是树的根节点。同时，字符串从右至左的节点顺序，是基于根节点的广度优先遍历（BFS）结果，即：
			- 根节点->左子树节点->右子树节点
			- （左子树节点）->（左）左节点->（左）右节点
			- （右子树节点）->（右）左节点->（右）右节点
			- （（左）左节点）-> 左节点 -> 右节点
			-  ...
		- 如何寻找左右树根节点：通过观察，大写字母的数量+1 = 小写字母的数量，即算子的数量总是运算符+1。
		- 从右向左，自根节点的下一个字母开始计算大写字母数量和小写字母数量，当检查到第i个字母 && 小写字母数量=大写字母+1时，即找到了一棵子树的根节点的位置（i+小写字母-1+大写字母），保存根节点的字母并标记位置，从位置i开始遍历寻找另一个子树的根节点位置...
		- 从左子树根节点位置开始遍历，寻找左子树的两个子树根节点，添加；再从右子树根节点位置开始遍历，寻找右子树的两个子树根节点，添加；左子树的左子树...左子树的右子树...右子树的左子树...右子树的右子树...直到所有节点都遍历完毕。即为队列计算

	---
- #### UVAOJ 540 Team Queue（Map+双队列）
	- 题目大意：模拟队伍队列的进出过程
	- 限制条件：
		1.	从队列前头遍历，如果队列中有同一个队伍的成员，则插入同队伍成员的最后；如果没有同队伍成员，则插入整个队列的最后
		2.	出队列时，整个队列最前头的成员离开
		3.	可能有超过20万条命令，故插入和出队列的耗时必须短
	- 思路：双队列保存队伍状态和各队伍成员状态
		- queue< int > qteam, qmember[MAXN] : qteam 保存的是整个队列中存在的队列ID，
		   i = qteam.front()返回最前端队列，qmember[i]表示队伍i的队伍
		（还是写的少了...queue居然还可以做成数组...）
		- map<int, int> team：字典，建立成员与队伍id的映射，team[value]返回的是成员value的队伍
	---
- #### UVAOJ 10050 Hartals (数组记录过程)
	- 题目大意：给p个数表示各组织活动的周期，求在D天内发生的活动总和
	- 限制条件：
		1. p不会是7的倍数
		2. 第一天必定是星期天
		3. 周五和周六是假期，不会发生活动
		4. 同一天发生多次活动的时候，仅计算一次
	- 思路：
		-	设定一个数组记录D天的每一天是否发生过活动，D[i]=0表示第i天还没有发生过活动，D[i]=1表示第i天已经发生过活动。
		-	设day=p[i]，循环day+=p[i]（day<D），判断那天是否发生过活动以及那天是否为周五或周六
		-	判断周五/周六的办法，day **mod** 7 = 5时为星期五，= 6时为星期六
---

# 大白书

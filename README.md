《算法竞赛入门经典》（小白书）与《算法竞赛入门经典训练指南》（大白书）的习题笔记

# 小白书

## 第六章--数据结构：

- ### 线性表：
- #### UVAOJ 127 "Accordian" Patience （模拟，结构体+链表）
	- 题目大意：给你五十二张牌, 重复下列操作，直至无法操作：从左到右遍历，当扑克牌与其左一或左三的扑克牌堆顶部牌拥有过相同的花色或者相同数字时，即为匹配成功，将该扑克牌移到匹配的左一或左三的牌堆顶部。如果同时可以移到左一和左三，则优先移到左三顶部。移动之后，观察能否再次移动，直至不能移动，继续遍历下一张牌。当一个牌堆的所有牌都被移走时，删除这个牌堆，右边的牌堆补上空缺。现在求有多少牌堆会剩下，以及各牌堆有多少张牌。
	- 思路：建立卡牌的结构体保存花色和卡牌，建立牌堆的结构体保存卡牌，左右牌堆的指针，当前牌数。然后根据输入顺序建立牌堆的链表，每个牌堆的初始卡牌即为输入的相应卡牌。先看左三牌堆（需确认左三存在），再看左一牌堆，匹配的时候移动卡牌
	----
- #### UVAOJ 101 The Blocks Problem （模拟，结构体+链表）
	- 题目大意：给N个小方块，从左到右编号（0~N-1），形成N个块堆，可进行4种操作：
		- （1）move A onto B：将A方块和B方块上的所有方块回归原位，然后将A放在B上
		- （2）move A over B：将A方块上的所有方块回归原位，然后将A放在B所在的块堆顶部
		- （3）pile A onto B：将B方块上的所有方块回归原位，然后将A及其以上的方块整体移到B上（移动过程中A及其以上的方块保持原来的上下顺序不变）
		- （4）pile A over B：将A及其以上的方块整体移动到B所在的快堆顶部上（移动过程中A及其以上的方块保持原来的上下顺序不变）
		- 现在给出一系列命令，输出所有操作结束以后，各块堆的拥有的方块
	- 思路：模拟，创建方块的结构体保存方块编号和上下信息，创建方块结构体的数组，根据命令进行操作。最后遍历结构体数组，如果该方块下方存在别的方块，则意味着它不在自己的块堆，不输出信息；如果下方不存在别的方块，则从下向上输出自己以及以上的方块的信息。因为所有操作都是将方块放在另一个方块的上方，而不是下方，所以不存在“自己在别的块堆，而自己的块堆存在别的方块”的情况
	----
- #### UVAOJ 133 The Dole Queue （链表）
	- 题目大意：有N个候选人和2个领导。候选人面朝内手拉手围成一个圈，每个人都有自己的编号，从1到N，1号候选人的左手边为N号候选人。1个领导从1号开始逆时针点人（包括1号），最终被点到的人会离开队伍，而离开队伍的人的左右两边的候选人会重新拉手；2号领导从N号开始顺时针点人（包含N号）。在点完人后，领导会按自己点人方向选择下一个候选人，并从该候选人开始继续点人，直到所有人都离开。求离开队伍的人的顺序
	- 限制条件：
		1. 被两个领导点到的候选人会同时离开队伍
		2. 被两个领导同时点到的候选人也会离开队伍，但输出只会输出一次
	- 思路：题目不难，创建链表，将所有节点按顺序相连，每次有人离开时，相邻节点重新相连。需要注意的是离队后领导指向的下一个候选人的选择。虽然题目说是同时离开，但代码执行的时候是有先后的，如果一个领导的下一个候选人正好是另一个领导这次点名的人，那么应该顺延到再下一个（当剩下的候选人总是小于等于2时，可认定不存在下一个合格的候选人，不应该继续遍历）
	---
- #### UVAOJ 10152 ShellSort （结构体+数组）
	- 题目大意：给两套字符串，一套为现在的顺序（从上到下），一套为目标的顺序（从上到下），现在可以对现有字符串组进行操作：将任意字符串抽出，放在整组字符串的最顶部。求，从现有顺序到目标顺序的操作顺序（要求操作次数最少）
	- 思路：目标组中越底部的字符串越需要尽早操作，所以从现有组和目标组底部开始对比，如果匹配，则意味着不需要对该字符串进行操作，对目标组该字符串进行标记；如果不匹配，则不标记。在对现有组进行操作时，上面的字符串会下落，如果弥补空缺的那个字符串正好是它的目标位置，则可以不需要对它操作又能达到目标位置，减少了字符串的操作次数。最后，从底部遍历目标组，按序输出没有被标记的字符串。
	---
- #### UVAOJ 673 Parentheses Balance （栈）
	- 题目大意：输入一串括号的字符串，判断是否合规
	- 思路：遇到左括号就压入栈，遇到右括号就弹出栈顶元素，看是否匹配；当然也可以用数组模拟栈
	---
- #### UVAOJ 442 Matrix Chain Multiplication （结构体+栈+矩阵乘法）
	- 题目大意：矩阵乘法的先后计算顺序会影响计算的速度，当A（50,10），B（10，20），C（20,10）三个矩阵相乘时，先计算AB再计算AB和C时，需要进行15000次元素间的乘法计算；而先计算BC再计算A和BC时，只需要进行3500次乘法计算。现在给出一些算式，其中会包含矩阵和一些括号，求各算式的乘法计算的次数。
	- 思路：用结构体保存矩阵的行数和列数，用数组（矩阵名-'A'）或者Map（map<char, 矩阵结构体>）保存矩阵名与矩阵结构体的映射。设一个结构体类型的栈，忽略'('，遇到矩阵就压入栈，遇到')'就弹出顶部的两个矩阵相乘，将结果压入栈。
	- 矩阵乘法次数的计算：MxN的矩阵*NxP的矩阵 = MxNxP
	- 矩阵乘法：MxN的矩阵*NxP的矩阵 = MxP的矩阵
---
- #### UVAOJ 11111 Generalized Matrioshkas（结构体+栈）
	- 题目大意：俄罗斯套娃，用一个正数和一个负数表示拆开的套娃的两半部分，正数表示套娃内的容积。与只能套一个套娃的传统套娃不同，新版套娃可以包含多个套娃，套娃中又可以包含多个套娃。给一串数字，判断是否能组成一个合规的套娃。（题目不难，但是有些关键信息没给，做的很痛苦）
	- 限制条件：
		1. 大套娃内部包含的小套娃总体积必须小于大套娃的容积
		2. 套娃内部的小套娃必须是完整的（即必须负数与正数成对）
		3. 虽然题目没讲，但是Debug数据中表示，空字符串也是合规的
		4. 虽然题目没讲，但是本题的数组最少需要开30000以上的空间
	- 思路：结构体保存套娃的容积以及小套娃的总体积，开一个结构体Stack，当遇到负数时，压入栈；当遇到正数时，弹出栈顶的结构体，判断是否配套。配套时，看自己的小套娃总体积是否超过自己的容积。不超过容积时，将自己的体积添加到上一层套娃的小套娃总体积中。继续遍历...
---
- #### UVAOJ 11234 Expressions（二叉树与层遍历BFS模拟）
	- 题目大意：后序计算是栈计算，每次遇到算术符号时，弹出栈顶部的两个元素，运算，再将结果压入栈内。现在希望通过用队列实现栈计算一样的结果。即，输入栈计算的字符串，输出队列计算的字符串
	- 思路1：建立二叉树，逐层遍历
	- 思路2：模拟遍历过程
		- 通过观察发现，字符串的最后一个元素一定是树的根节点。同时，字符串从右至左的节点顺序，是基于根节点的广度优先遍历（BFS）结果，即：
			- 根节点->左子树节点->右子树节点
			- （左子树节点）->（左）左节点->（左）右节点
			- （右子树节点）->（右）左节点->（右）右节点
			- （（左）左节点）-> 左节点 -> 右节点
			-  ...
		- 如何寻找左右树根节点：通过观察，大写字母的数量+1 = 小写字母的数量，即算子的数量总是运算符+1。
		- 从右向左，自根节点的下一个字母开始计算大写字母数量和小写字母数量，当检查到第i个字母 && 小写字母数量=大写字母+1时，即找到了一棵子树的根节点的位置（i+小写字母-1+大写字母），保存根节点的字母并标记位置，从位置i开始遍历寻找另一个子树的根节点位置...
		- 从左子树根节点位置开始遍历，寻找左子树的两个子树根节点，添加；再从右子树根节点位置开始遍历，寻找右子树的两个子树根节点，添加；左子树的左子树...左子树的右子树...右子树的左子树...右子树的右子树...直到所有节点都遍历完毕。即为队列计算

	---
- #### UVAOJ 540 Team Queue（Map+双队列）
	- 题目大意：模拟队伍队列的进出过程
	- 限制条件：
		1.	从队列前头遍历，如果队列中有同一个队伍的成员，则插入同队伍成员的最后；如果没有同队伍成员，则插入整个队列的最后
		2.	出队列时，整个队列最前头的成员离开
		3.	可能有超过20万条命令，故插入和出队列的耗时必须短
	- 思路：双队列保存队伍状态和各队伍成员状态
		- queue< int > qteam, qmember[MAXN] : qteam 保存的是整个队列中存在的队列ID，
		   i = qteam.front()返回最前端队列，qmember[i]表示队伍i的队伍
		（还是写的少了...queue居然还可以做成数组...）
		- map<int, int> team：字典，建立成员与队伍id的映射，team[value]返回的是成员value的队伍
	---
- #### UVAOJ 10050 Hartals (数组记录过程)
	- 题目大意：给p个数表示各组织活动的周期，求在D天内发生的活动总和
	- 限制条件：
		1. p不会是7的倍数
		2. 第一天必定是星期天
		3. 周五和周六是假期，不会发生活动
		4. 同一天发生多次活动的时候，仅计算一次
	- 思路：
		-	设定一个数组记录D天的每一天是否发生过活动，D[i]=0表示第i天还没有发生过活动，D[i]=1表示第i天已经发生过活动。
		-	设day=p[i]，循环day+=p[i]（day<D），判断那天是否发生过活动以及那天是否为周五或周六
		-	判断周五/周六的办法，day **mod** 7 = 5时为星期五，= 6时为星期六
---

# 大白书

## 第一章--算法基础设计
- ### UVAOJ11292 The Fragon of Loowater （排序）
	- 题目大意：有一条n个头的龙，需要雇佣勇者去屠龙，已知可雇佣的勇者的能力X，可以砍下直径不超过X的龙头，佣金为X，求能否用最少的金钱屠龙，如果可以，输出金钱；否则，输出对应文本。
	- 限制条件：每个勇者只能雇用一次，且一次只能砍一个头
	- 思路：对龙头和勇者的能力分别进行排序，从小开始遍历勇者和龙头，当勇者不能砍下当前龙头时，寻找下一个勇者；当龙头被砍下时，佣金+=X，寻找下一个勇者和下一个龙头。
	---
-	### UVAOJ11729 Commando War （贪心，结构体）
	-	题目大意：有一系列任务需要布置给下属完成，每个任务消耗X分钟交待，需要下属消耗Y分钟完成。一旦交待完成，就可以继续交待下一个任务给另一个下属，而下属们可以同时处理他们自己的任务，求完成所有任务所消耗的最少的时间。
	-	思路：需要考虑几种情况，
		1. 假设，任务A的总耗时比任务B的执行时间短。则，先执行A再执行B，耗时为（Xa+Xb+Yb）；先执行B再执行A，耗时为（Xb+Yb）< （Xa+Xb+Yb）
		2. 假设，任务A的总耗时比任务B的执行时间长，但比任务B的总耗时短。则，先执行A再执行B的耗时为（Xa+Xb+Yb）；先执行B再执行A，耗时为（Xb+Xa+Ya）。由此可见，若任务A的执行时间大于任务B的执行时间，那么应该先执行A；若任务B的执行时间大于任务A的执行时间时，应该先执行B；且这个安排于A，B的交待时间无关
		3. 如果出现一个任务A总耗时比任务B的总耗时长，那么就是假设2的倒置情况，依然需要满足“执行时间长的应该先执行”的原则。
	- 基于上面的假设，建立任务的结构体，依照执行时间对所有任务进行排序。然后统计执行时间：Xs+=X（累计交待时间），time = max（time，Xs+Y）
---
- ### UVAOJ11300 Spreading The Wealth （数论）
	- 题目大意：圆桌旁坐着n个人，每个人都有一定数量的金币，金币总数能被n整除。每个人可以给左右相邻的人一些金币，最终使得每个人的金币数目相等。求被转手的金币数量的最小值。
	- 思路：
		- 最终金币数M=（所有金币数）/人数
		- 对于第一个人，初始金币A1，他给左边的人x1个金币，又收到右边的人x2个金币，现在第一个人的总金币数=A1-x1+x2=M，通过调整可得：x2=M-A1+x1=x1-C1，C1=A1-M+C0, C0=0
		- 对于第二个人，初始金币A2，他给左边的人x2个金币，又收到右边的人x3个金币，现在第一个人的总金币数=A2-x2+x3=M，通过调整可得：x3=M-A2+x2=x1-C2，C2=A2-M+C1
		- ...
		- 对于第N-1个人，初始金币An-1，他给左边的人xn-1个金币，又收到右边的人xn个金币，现在第N-1个人的总金币数=An-1-xn-1+xn=M，调整可得：xn=M-An-1+xn-1 = x1-Cn-1, Cn-1 = An-1-M+Cn-2
		- 对于第N个人，初始金币An，他给左边的人xn个金币，有收到右手边（第一个人）给的x1个金币，那么第N个人的总金币数=An-xn+x1=M，然而我们从中并不能推导出有用的信息。因为当所有人（除第N个人）给出和收到的金币确定时，第N个人需要给的和收到的金币也随之确定
		- 由上述所有的算式可得，需要转手的硬币总数为|x1-C0|+|x1-C1|+|x1-C2|+...+|xn-Cn-1|，而题目需要这个总数最小（C0=0）。几何角度来讲，|x1-Ci|表示的是数轴上x1到点Ci的距离，那么问题就转化成，找到一个点，使得这个点到所有其他点的距离最小。**这里需要用到一个数论理论：有序数列中，中位数到各点的距离一定是最短的。如果数列内元素数量为奇数，那么中位数就是中间的那个元素；如果为偶数，那么中位数就是中间两个元素之间的任意位置（因为这个点位于中间时，不论向左还是向右移动，与一边各点增加的距离永远等于与另一边各点减少的距离）**。
		- 根据上面的推导，计算各个Ci，进行排序，然后选出中位数，最后累加起来
		---
- ### LA3708 Graveyard （缩放+数论）
- 题目大意：在一个周长为10000的圆上等距分布着n个雕像，现在要加入m个雕像（位置随意摆放），希望所有n+m个雕像在圆周上均匀分布，就必须移动一部分已有的雕像，求最小的移动距离总和。
- 思路：n个雕像中，要达到最小移动距离，必有1个雕像不需要移动，原理类似于: 因为一个有序数列中，中位数到所有点的距离之和最小
	- 将圆缩放10000倍，并以一个雕像为原点，计算其余n-1个雕像的距离，并以此作为数轴坐标，比如n=3，那么三个点的坐标为，0, 1/3, 2/3
	- 将单位圆放大n+m倍，得到三个点新的坐标0, 4/3, 8/3。这么做的理由是：通过放大n+m倍，可使所有雕像的坐标都是整数，且彼此之间的距离为1。也正因为所有雕像的坐标在添加m个新雕像后必然为整数，所以可以通过新坐标计算到最近整数点的距离R
	- 会不会有两个雕像的最近整数点相同，而撞到一起呢？答案是不会。因为如果他们整数点坐标相同，那么他们的现有坐标之间的距离应该不超过1，然而在添加m个雕像后，彼此之间的距离才会到1，没添加之前应该比1大才对。故，不会出现撞车的情况
	- 计算出R之后，再缩放n+m倍，得到单位圆下的移动距离，累加起来，再放大10000倍，即是移动距离的最小值。
	----
